function TorsionValuation(K, l, x)
    L := [];
    // Handle zero element: valuation is infinity
    if x eq 0 then
        return Infinity();
    end if;
    // Get the ring of integers of K
    OK := Integers(K);
    // Factor the ideal generated by l
    fac := Factorization(ideal<OK | l>);
    // Ensure there is at least one prime above l
    if #fac eq 0 then
        error "No prime ideals found above", l;
    end if;
    // Select the nth prime ideal above l
    for n := 1 to #fac do
        lambda := fac[n][1];
        val:=Valuation(x, lambda);
        f:=InertiaDegree(lambda);
        L:=Append(L,f*val);
    end for;
    m, pos := Max(L);
    return m;
end function;

function CorrectValuation(K, l)
    OK := Integers(K);
    F := Factorization(l*OK);
    if #F eq 1 and F[1][2] eq 1 then
    // If the prime l is totally inert then the valuation computed is exactly the valuation of gcd Np.
        return true;
    else
        return false;
    end if;
end function;

function PossibleTorsionOrders(Nlbd, Nubd, deg)
// List of the predicted torsion orders for the A_f
list_predicted := [];
// List of the torsion orders matching the bound gcd Np
list := [];
// List of the primes dividing the predicted torsion orders
list_of_primes := [];
for N := Nlbd to Nubd do
// Compute the newforms of level N and weight 2
    S := CuspForms(Gamma1(N), 2);
    st := Max(PrecisionBound(S), 50); // Precision bound for the Fourier coefficients
    nfs := Newforms(S);
    for i := 1 to #nfs do
        f := nfs[i][1];
        D := Degree(f);
        // Check if the degree of the newform matches the specified degree
        if D eq deg then
            chi := DirichletCharacter(f); //Nebentypus character
            K := CoefficientField(f);
            OK := Integers(K);
            L := [];
            LNp := [];
            for p in PrimesInInterval(2, st) do
                Facp := Factorization(p*OK);
                ram := [e[2] : e in Facp];
                ep := Max(ram); // Absolute ramification index
                // Check if torsion injects into the reduction
                if ep lt p-1 then
                    if N mod p ne 0 then
                    // Compute P_p^\lambda(1) and the corresponding valuation at l of the torsion order
                        bp := 1;
                        ap := Coefficient(f, p);
                        chip := chi(p);
                        Fchi := Parent(chip);
                        F := Compositum(Fchi, K);
                        x := F!chip*p+1-ap;
                        X := Integers()!Norm(x);
                        fac := Factorization(X);
                        for i := 1 to #fac do
                            l := fac[i][1];
                            fn := TorsionValuation(K, l, x);
                            bp := bp * l ^ fn;
                        end for;
                        L := Append(L, bp);
                        LNp := Append(LNp, X);
                    end if;
                end if;
            end for;
            // Take the gcd over all primes
            g := GCD(L);
            // Take the gcd of the rational points over the reductions for the same primes
            gp := GCD(LNp);
            if g eq gp then
            // If they are equal, then the precited order is equal to the bound. We add it to all the lists.
                if g notin list then 
                    list := Append(list, g); 
                end if;
                if g notin list_predicted then
                    list_predicted := Append(list_predicted, g); 
                    F := Factorization(g);
                    for i := 1 to #F do
                    if F[i][1] notin list_of_primes then
                    list_of_primes := Append(list_of_primes, F[i][1]);
                    end if;
                    end for;
                end if;
                print "N =", N;
                print "f =", f;
                print "predicted torsion order equal to bound =", g;
            else
            // If they are not equal, we only add it to the list of the predicted torsion orders.
                if g notin list_predicted then
                    list_predicted := Append(list_predicted, g); 
                    F := Factorization(g);
                    for i := 1 to #F do
                    if F[i][1] notin list_of_primes then
                    list_of_primes := Append(list_of_primes, F[i][1]);
                    end if;
                    end for;
                end if;
                print "N =", N;
                print "f =", f;
                print "predicted torsion order =", g; //this number divides the torsion order of an abelian variety isogenous to A_f. It is equal if the primes dividing g have a unique prime above them in K.
            end if;
        end if;
    end for;
end for;
return list_predicted,  list,   list_of_primes;
end function;


