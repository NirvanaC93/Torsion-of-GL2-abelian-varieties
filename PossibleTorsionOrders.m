
function TorsionValuation(K, l, x)
    L:=[];
    // Handle zero element: valuation is infinity
    if x eq 0 then
        return Infinity();
    end if;

    // Get the ring of integers of K
    OK := Integers(K);
    
    // Factor the ideal generated by l
    fac := Factorization(ideal<OK | l>);
    
    // Ensure there is at least one prime above l
    if #fac eq 0 then
        error "No prime ideals found above", l;
    end if;
    


    // Select the nth prime ideal above l
    for n := 1 to #fac do
        lambda := fac[n][1];
        val:=Valuation(x, lambda);
        f:=InertiaDegree(lambda);
        L:=Append(L,f*val);

    end for;

    m,pos:=Max(L);

    return m;
end function;

function CorrectValuation(K,l)
    OK := Integers(K);
    F := Factorization( l*OK );
    if #F eq 1 and F[1][2] eq 1 then
        return true;
    else
        return false;
    end if;
end function;



function PossibleTorsionOrders(Nlbd,Nubd, deg)
list_naive := [];
list := [];
list_of_primes := [];
for N:=Nlbd to Nubd do
    S:=CuspForms(Gamma1(N),2);
    st:=Max(PrecisionBound(S),50); 
    nfs := Newforms(S);
    for i:=1 to #nfs do
        f:=nfs[i][1];
        D:=Degree(f);
        if D eq deg then
            chi:= DirichletCharacter(f); //Nebentypus character
            K:=CoefficientField(f);
            OK:=Integers(K);
            L:=[];
            LNp:=[];
            for p in PrimesInInterval(2,st) do
                Facp:=Factorization(p*OK);
                ram:=[e[2] : e in Facp];
                ep:=Max(ram); // Absolute ramification index
                if ep lt p-1 then
                    if N mod p ne 0 then
                        bp := 1;
                        chip:=chi(p);
                        Fchi:=Parent(chip);
                        F:=Compositum(Fchi,K);
                        x := F!(p+1-Coefficient(f,p));
                        X := Integers()!Norm(x);
                        fac := Factorization(X);
                        for i := 1 to #fac do
                            l:=fac[i][1];
                            fn:=TorsionValuation(K, l, x);
                            bp := bp * l ^ fn;
                        end for;
                        L:=Append(L,bp);
                        LNp:=Append(LNp,X);
                    end if;
                end if;
            end for;
            g:=GCD(L);
            gp := GCD(LNp);
            if g eq gp then
                if g notin list_naive then 
                    list_naive := Append(list_naive,g);
                    F := Factorization(g);
                    for i := 1 to #F do
                    if F[i][1] notin list_of_primes then
                    list_of_primes:=Append(list_of_primes,F[i][1]);
                    end if;
                    end for;
                end if;
                if g notin list then
                    list := Append(list,g); 
                end if;
                print "N =", N;
                print "f =", f;
                print "torsion order equal to bound =", g;
            else
                print "N =", N;
                print "f =", f;
                print "naive_torsion_order =", g; //this number divides the torsion order of an abelian variety isogenous to A_f. It is equal if the primes dividing g have a unique prime above them in K.
            end if;
        end if;
    end for;
end for;
return list_naive,list,list_of_primes;
end function;


